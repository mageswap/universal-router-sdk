{"version":3,"file":"universal-router-sdk.cjs.production.min.js","sources":["../src/entities/Command.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/inputTokens.ts","../src/swapRouter.ts","../src/entities/NFTTrade.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRareV2.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/entities/protocols/unwrapWETH.ts"],"sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n  UnwrapWETH = 'UnwrapWETH',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT2_PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n  BALANCE_CHECK_ERC20 = 0x0e,\n\n  // NFT-related command types\n  SEAPORT = 0x10,\n  LOOKS_RARE_V2 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  // 0x14\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n  SWEEP_ERC721 = 0x17,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n  SWEEP_ERC1155 = 0x1d,\n  ELEMENT_MARKET = 0x1e,\n\n  SEAPORT_V1_4 = 0x20,\n  EXECUTE_SUB_PLAN = 0x21,\n  APPROVE_ERC20 = 0x22,\n}\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTIBLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT,\n  CommandType.SEAPORT_V1_4,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_V2,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n  CommandType.EXECUTE_SUB_PLAN,\n  CommandType.CRYPTOPUNKS,\n  CommandType.ELEMENT_MARKET,\n])\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details,address spender,uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details,address spender,uint256 sigDeadline)'\n\nconst PERMIT2_TRANSFER_FROM_STRUCT = '(address from,address to,uint160 amount,address token)'\nconst PERMIT2_TRANSFER_FROM_BATCH_STRUCT = PERMIT2_TRANSFER_FROM_STRUCT + '[]'\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  // Batch Reverts\n  [CommandType.EXECUTE_SUB_PLAN]: ['bytes', 'bytes[]'],\n\n  // Permit2 Actions\n  [CommandType.PERMIT2_PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: [PERMIT2_TRANSFER_FROM_BATCH_STRUCT],\n\n  // Uniswap Actions\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n\n  // Token Actions and Checks\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.SWEEP_ERC721]: ['address', 'address', 'uint256'],\n  [CommandType.SWEEP_ERC1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.BALANCE_CHECK_ERC20]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.APPROVE_ERC20]: ['address', 'uint256'],\n\n  // NFT Markets\n  [CommandType.SEAPORT]: ['uint256', 'bytes'],\n  [CommandType.SEAPORT_V1_4]: ['uint256', 'bytes'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_V2]: ['uint256', 'bytes'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n  [CommandType.ELEMENT_MARKET]: ['uint256', 'bytes'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addSubPlan(subplan: RoutePlanner): void {\n    this.addCommand(CommandType.EXECUTE_SUB_PLAN, [subplan.commands, subplan.inputs], true)\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTIBLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: // mainnet\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 5: // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 137: // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 80001: // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 10: // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654'\n    case 420: // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42161: // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 421613: // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42220: // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F'\n    case 44787: // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 56: // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897'\n    case 250: //fantom\n      return \"0x22AB7B8f0cf0288904dfCb192d17765C808dE4c7\"\n    default:\n      throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  }\n}\n\nexport const WETH_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'\n    case 5: // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6'\n    case 137: // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\n    case 80001: // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889'\n    case 10: // optimism\n      return '0x4200000000000000000000000000000000000006'\n    case 420: // optimism goerli\n      return '0x4200000000000000000000000000000000000006'\n    case 42161: // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1'\n    case 421613: // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3'\n    case 56: // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'\n    default:\n      throw new Error(`WETH9 or UniversalRouter not deployed on chain ${chainId}`)\n  }\n}\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const MAX_UINT256 = BigNumber.from(2).pow(256).sub(1)\nexport const MAX_UINT160 = BigNumber.from(2).pow(160).sub(1)\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n\nexport const OPENSEA_CONDUIT_SPENDER_ID = 0\nexport const SUDOSWAP_SPENDER_ID = 1\n","import JSBI from 'jsbi'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@mageswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@mageswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@mageswap/router-sdk'\nimport { Permit2Permit } from '../../utils/inputTokens'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@mageswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE } from '../../utils/constants'\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  inputTokenPermit?: Permit2Permit\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {}\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    let payerIsUser = true\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false\n    }\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const inputIsNative = this.trade.inputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      }\n    }\n\n    if (inputIsNative && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n","import invariant from 'tiny-invariant'\nimport { ethers } from 'ethers'\nimport { PermitSingle } from '@mageswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\nimport { OPENSEA_CONDUIT_SPENDER_ID, ROUTER_AS_RECIPIENT, SUDOSWAP_SPENDER_ID } from './constants'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nexport type ApproveProtocol = {\n  token: string\n  protocol: string\n}\n\nexport type Permit2TransferFrom = {\n  token: string\n  amount: string\n  recipient?: string\n}\n\nexport type InputTokenOptions = {\n  approval?: ApproveProtocol\n  permit2Permit?: Permit2Permit\n  permit2TransferFrom?: Permit2TransferFrom\n}\n\nconst SIGNATURE_LENGTH = 65\nconst EIP_2098_SIGNATURE_LENGTH = 64\n\nexport function encodePermit(planner: RoutePlanner, permit2: Permit2Permit): void {\n  let signature = permit2.signature\n\n  const length = ethers.utils.arrayify(permit2.signature).length\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit2.signature))\n  }\n\n  planner.addCommand(CommandType.PERMIT2_PERMIT, [permit2, signature])\n}\n\n// Handles the encoding of commands needed to gather input tokens for a trade\n// Approval: The router approving another address to take tokens.\n//   note: Only seaport and sudoswap support this action. Approvals are left open.\n// Permit: A Permit2 signature-based Permit to allow the router to access a user's tokens\n// Transfer: A Permit2 TransferFrom of tokens from a user to either the router or another address\nexport function encodeInputTokenOptions(planner: RoutePlanner, options: InputTokenOptions) {\n  // first ensure that all tokens provided for encoding are the same\n  if (!!options.approval && !!options.permit2Permit)\n    invariant(options.approval.token === options.permit2Permit.details.token, `inconsistent token`)\n  if (!!options.approval && !!options.permit2TransferFrom)\n    invariant(options.approval.token === options.permit2TransferFrom.token, `inconsistent token`)\n  if (!!options.permit2TransferFrom && !!options.permit2Permit)\n    invariant(options.permit2TransferFrom.token === options.permit2Permit.details.token, `inconsistent token`)\n\n  // if an options.approval is required, add it\n  if (!!options.approval) {\n    planner.addCommand(CommandType.APPROVE_ERC20, [\n      options.approval.token,\n      mapApprovalProtocol(options.approval.protocol),\n    ])\n  }\n\n  // if this order has a options.permit2Permit, encode it\n  if (!!options.permit2Permit) {\n    encodePermit(planner, options.permit2Permit)\n  }\n\n  if (!!options.permit2TransferFrom) {\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [\n      options.permit2TransferFrom.token,\n      options.permit2TransferFrom.recipient ? options.permit2TransferFrom.recipient : ROUTER_AS_RECIPIENT,\n      options.permit2TransferFrom.amount,\n    ])\n  }\n}\n\nfunction mapApprovalProtocol(protocolAddress: string): number {\n  switch (protocolAddress.toLowerCase()) {\n    case '0x00000000006c3852cbef3e08e8df289169ede581': // Seaport v1.1\n      return OPENSEA_CONDUIT_SPENDER_ID\n    case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\n      return OPENSEA_CONDUIT_SPENDER_ID\n    case '0x2b2e8cda09bba9660dca5cb6233787738ad68329': // Sudoswap\n      return SUDOSWAP_SPENDER_ID\n    default:\n      throw new Error('unsupported protocol address')\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { abi } from '@mageswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@mageswap/v3-sdk'\nimport { Trade as RouterTrade } from '@mageswap/router-sdk'\nimport { Currency, TradeType } from '@mageswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/inputTokens'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    for (const trade of trades) {\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        /**\n         * is UniswapTrade\n         */\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        uniswapTrade.encode(planner, { allowRevert: false })\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\n        const UnwrapWETH = trade as UnwrapWETH\n        trade.encode(planner, { allowRevert: false })\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo).\n    // Note: NFTXV2 sends excess ETH to the caller (router), not the specified recipient\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\nimport { ElementData } from './protocols/element-market'\nimport { LooksRareV2Data } from './protocols/looksRareV2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareV2Data\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n  | ElementData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  // optional parameter for the markets that accept ERC20s not just ETH\n  abstract getTotalPrice(token?: string): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRareV2 = 'looksrareV2',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n  Element = 'element',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/LooksRareV2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber } from 'ethers'\nimport { ZERO_ADDRESS } from '../../utils/constants'\n\nexport type MakerOrder = {\n  quoteType: number\n  globalNonce: string\n  subsetNonce: string\n  orderNonce: string\n  strategyId: number\n  collectionType: number\n  collection: string\n  currency: string\n  signer: string\n  startTime: number\n  endTime: number\n  price: string\n  itemIds: string[]\n  amounts: string[]\n  additionalParameters: string\n}\n\nexport type TakerOrder = {\n  recipient: string\n  additionalParameters: string\n}\n\nexport type MerkleProof = {\n  value: string\n  position: number\n}\n\nexport type MerkleTree = {\n  root: string\n  proof: MerkleProof[]\n}\n\nexport type LRV2APIOrder = MakerOrder & {\n  id: string\n  hash: string\n  signature: string\n  createdAt: string\n  merkleRoot: string\n  merkleProof: MerkleProof[]\n  status: string\n}\n\nexport type LooksRareV2Data = {\n  apiOrder: LRV2APIOrder\n  taker: string\n}\n\nexport class LooksRareV2Trade extends NFTTrade<LooksRareV2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n  private static ERC721_ORDER = 0\n\n  constructor(orders: LooksRareV2Data[]) {\n    super(Market.LooksRareV2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const { takerBid, makerOrder, makerSignature, value, merkleTree } = this.refactorAPIData(item)\n      const calldata = LooksRareV2Trade.INTERFACE.encodeFunctionData('executeTakerBid', [\n        takerBid,\n        makerOrder,\n        makerSignature,\n        merkleTree,\n        ZERO_ADDRESS, // affiliate\n      ])\n\n      planner.addCommand(CommandType.LOOKS_RARE_V2, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      const tokenAddress = item.apiOrder.collection\n      const tokenType =\n        item.apiOrder.collectionType == LooksRareV2Trade.ERC721_ORDER ? TokenType.ERC721 : TokenType.ERC1155\n      for (const tokenId of item.apiOrder.itemIds)\n        buyItems.push({\n          tokenAddress,\n          tokenId,\n          tokenType,\n        })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.apiOrder.price)\n    }\n    return total\n  }\n\n  private refactorAPIData(data: LooksRareV2Data): {\n    takerBid: TakerOrder\n    makerOrder: MakerOrder\n    makerSignature: string\n    value: BigNumber\n    merkleTree: MerkleTree\n  } {\n    const makerOrder: MakerOrder = { ...data.apiOrder }\n\n    const makerSignature: string = data.apiOrder.signature\n\n    const takerBid: TakerOrder = {\n      recipient: data.taker,\n      additionalParameters: '0x',\n    }\n\n    const value: BigNumber = BigNumber.from(data.apiOrder.price)\n\n    const merkleTree: MerkleTree = {\n      root: data.apiOrder.merkleRoot,\n      proof: data.apiOrder.merkleProof,\n    }\n\n    return { takerBid, makerOrder, makerSignature, value, merkleTree }\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFTXData = {\n  recipient: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n  swapCalldata: string\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        order.swapCalldata,\n        order.recipient,\n      ])\n\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport abi from '../../../abis/Seaport.json'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\nimport { ETH_ADDRESS } from '../../utils/constants'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n  protocolAddress: string\n  inputTokenProcessing?: InputTokenProcessing[]\n}\n\nexport type InputTokenProcessing = {\n  token: string\n  permit2Permit?: Permit2Permit\n  protocolApproval: boolean\n  permit2TransferFrom: boolean\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n\n      if (!!order.inputTokenProcessing) {\n        for (const inputToken of order.inputTokenProcessing)\n          encodeInputTokenOptions(planner, {\n            approval: inputToken.protocolApproval\n              ? { token: inputToken.token, protocol: order.protocolAddress }\n              : undefined,\n            permit2Permit: inputToken.permit2Permit,\n            permit2TransferFrom: inputToken.permit2TransferFrom\n              ? { token: inputToken.token, amount: this.getTotalOrderPrice(order, inputToken.token).toString() }\n              : undefined,\n          })\n      }\n\n      planner.addCommand(\n        this.commandMap(order.protocolAddress),\n        [this.getTotalOrderPrice(order, ETH_ADDRESS).toString(), calldata],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalOrderPrice(order: SeaportData, token: string = ETH_ADDRESS): BigNumber {\n    let totalOrderPrice = BigNumber.from(0)\n    for (const item of order.items) {\n      totalOrderPrice = totalOrderPrice.add(this.calculateValue(item.parameters.consideration, token))\n    }\n    return totalOrderPrice\n  }\n\n  getTotalPrice(token: string = ETH_ADDRESS): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration, token))\n      }\n    }\n    return totalPrice\n  }\n\n  private commandMap(protocolAddress: string): CommandType {\n    switch (protocolAddress.toLowerCase()) {\n      case '0x00000000006c3852cbef3e08e8df289169ede581': // Seaport v1.1\n        return CommandType.SEAPORT\n      case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\n        return CommandType.SEAPORT_V1_4\n      default:\n        throw new Error('unsupported Seaport address')\n    }\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    return { advancedOrder }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[], token: string): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) =>\n        consideration.token == token ? amt.add(consideration.startAmount) : amt,\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumberish } from 'ethers'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { ROUTER_AS_RECIPIENT, WETH_ADDRESS } from '../../utils/constants'\n\nexport class UnwrapWETH implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\n  readonly permit2Data: Permit2Permit\n  readonly wethAddress: string\n  readonly amount: BigNumberish\n\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\n    this.wethAddress = WETH_ADDRESS(chainId)\n    this.amount = amount\n\n    if (!!permit2) {\n      invariant(permit2.details.token === this.wethAddress, `must be permitting WETH address: ${this.wethAddress}`)\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\n      this.permit2Data = permit2\n    }\n  }\n\n  encode(planner: RoutePlanner, _: TradeConfig): void {\n    encodeInputTokenOptions(planner, {\n      permit2Permit: this.permit2Data,\n      permit2TransferFrom: {\n        token: this.wethAddress,\n        amount: this.amount.toString(),\n      },\n    })\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\n  }\n}\n"],"names":["RouterTradeType","CommandType","REVERTIBLE_COMMANDS","Set","SEAPORT","SEAPORT_V1_4","NFTX","LOOKS_RARE_V2","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","EXECUTE_SUB_PLAN","CRYPTOPUNKS","ELEMENT_MARKET","ABI_DEFINITION","_ABI_DEFINITION","PERMIT2_PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","PERMIT2_TRANSFER_FROM_STRUCT","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","SWEEP_ERC721","SWEEP_ERC1155","TRANSFER","PAY_PORTION","BALANCE_CHECK_ERC20","OWNER_CHECK_721","OWNER_CHECK_1155","APPROVE_ERC20","RoutePlanner","this","commands","inputs","_proto","prototype","addSubPlan","subplan","addCommand","type","parameters","allowRevert","command","encodedInput","defaultAbiCoder","encode","createCommand","push","has","Error","concat","toString","padStart","WETH_ADDRESS","chainId","CONTRACT_BALANCE","BigNumber","from","pow","ETH_ADDRESS","SENDER_AS_RECIPIENT","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","JSBI","BigInt","UniswapTrade","trade","options","planner","_config","payerIsUser","inputAmount","currency","isNative","maximumAmountIn","slippageTolerance","quotient","recipient","_this$options$recipie","_step","outputIsNative","outputAmount","inputIsNative","routerMustCustody","tradeType","TradeType","EXACT_INPUT","routes","length","_iterator","_createForOfIteratorHelperLoose","swaps","done","swap","value","route","protocol","Protocol","V2","addV2Swap","V3","addV3Swap","MIXED","addMixedSwap","minimumAmountOut","wrapped","address","EXACT_OUTPUT","priceImpact","greaterThan","_ref","V2Trade","path","map","pool","_ref2","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","Pool","Pair","outputToken","MixedRouteTrade","amountIn","amountOut","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","i","inputToken","input","section","getOutputOfPools","newRouteOriginal","MixedRouteSDK","token0","equals","token1","newRoute","MixedRoute","every","mixedRouteIsAllV3","encodeMixedRouteToPath","liquidityToken","encodePermit","permit2","signature","ethers","utils","arrayify","joinSignature","splitSignature","encodeInputTokenOptions","approval","permit2Permit","token","details","invariant","permit2TransferFrom","mapApprovalProtocol","amount","protocolAddress","toLowerCase","SwapRouter","swapCallParameters","trades","config","Array","isArray","nftTrades","filter","_","hasOwnProperty","orders","currentNativeValueInRouter","transactionValue","NFTTrade","nftTrade","tradePrice","getTotalPrice","lt","add","sub","uniswapTrade","swapOptions","inputTokenPermit","UnwrapWETH","encodePlan","swapNFTCallParameters","_step2","totalPrice","_iterator2","swapERC20CallParameters","inputCurrency","nativeCurrencyValue","deadline","deadlineOrPreviousBlockhash","undefined","calldata","INTERFACE","encodeFunctionData","toHexString","Interface","abi","Market","TokenType","market","CryptopunkTrade","_NFTTrade","call","Cryptopunks","_inheritsLoose","item","tokenId","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenType","Cryptopunk","_step3","total","_iterator3","FoundationTrade","Foundation","price","referrer","ERC721","LooksRareV2Trade","LooksRareV2","_this$refactorAPIData","refactorAPIData","takerBid","makerOrder","makerSignature","merkleTree","apiOrder","collection","collectionType","ERC721_ORDER","ERC1155","itemIds","_step4","_iterator4","data","_extends","taker","additionalParameters","root","merkleRoot","proof","merkleProof","NFT20Trade","order","tokenIds","tokenAmounts","fee","isV3","NFTXTrade","vaultId","swapCalldata","SeaportTrade","Seaport","advancedOrders","orderFulfillments","items","index","orderIndex","itemIndex","considerationFulFillments","getConsiderationFulfillments","_this$getAdvancedOrde","getAdvancedOrderParams","advancedOrder","OPENSEA_CONDUIT_KEY","inputTokenProcessing","protocolApproval","getTotalOrderPrice","commandMap","_step5","_iterator5","_step6","_iterator6","offer","identifierOrCriteria","_step7","totalOrderPrice","_iterator7","calculateValue","consideration","_step8","_iterator8","_step9","_iterator9","protocolDatas","considerationFulfillments","considerationRecipients","protocolData","_loop","j","findIndex","x","recipientIndex","numerator","denominator","extraData","considerations","reduce","amt","startAmount","SudoswapTrade","Sudoswap","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","nftIds","X2Y2Trade","X2Y2","getSighash","getFunction","signedInput","slice","tokenAmount","wethAddress","permit2Data"],"mappings":"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"}